
<!DOCTYPE html>
<html>

<head>
    <title>道格拉斯</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <style>
    </style>
</head>

<body>
    <a style="margin-left: 50px">输入：</a><input type="file" id="file" style="" />
    <button style="margin-left:15px;"onclick="Read()">确定</button>
    <br>
    <canvas id="map" style="margin-left:20px;border:1px solid #000;margin-top:10px;float:left"></canvas>


    <script>
        var canvas = document.getElementById('map');
        var ctx = canvas.getContext('2d');
        canvas.width = 400;
        canvas.height = 300;
        var border = {};        
        var polylines = [];        
        var points = [];        
        var polygon = [];        
        var polypoint = [];        
        var resDao = [];

        function Read() {
            var file = document.getElementById('file').files[0];
            var reader = new FileReader();
            reader.readAsText(file);
            var data = null;
            reader.onload = function (e) {
                data = this.result;
                polygon = [];
                DrawPolygon(data);
                LeftTurn();
                PolytoPoint();
                CheckDao();
            }
        }

        function PolygonArea(data) {//计算面积
            var s = data[0][1] * (data[data.length - 1][0] - data[1][0]);
            for (var i = 1; i < data.length; i++) {
                s += data[i][1] * (data[i - 1][0] - data[(i + 1) % data.length][0])
            }
            return -s / 2;
        }

        function CheckDao() {//
            var again = [];
            var area = [];
            for (var i = 0; i < polypoint.length; i++) {
                var a = PolygonArea(polypoint[i]);
                area.push({ id: i, area: a });
            }
            area.sort(function (a, b) {
                return a.area - b.area;
            });
            var dao = [];
            var reduce = [];
            for (var i = 0; i < area.length; i++) {
                if (area[i].area > 0) {
                    break;
                }
                else {
                    var index = area[i].id;
                    reduce.push(index);
                }
                if (i == 0) {
                    border = { id: index, data: polygon[index] };
                }
            }
            reduce.sort(function (a, b) {
                return a - b;
            });
            var temp1 = [];
            var temp2 = [];
            var n = 0;
            for (var i = 0; i < polypoint.length; i++) {
                if (i == reduce[n]) {
                    n++;
                }
                else {
                    temp1.push({ id: i, data: polypoint[i] });
                    temp2.push({ id: i, data: polygon[i] });
                }
            }
            polypoint = temp1;
            polygon = temp2;
            for (var i = 0; i < area.length; i++) {
                if (area[i].area > 0) {
                    break;
                }
                else {
                    for (var j = 0; j < area.length; j++) {
                        if (Math.abs(area[j].area - Math.abs(area[i].area)) < 0.000001) {
                            for (var k = 0; k < polygon.length; k++) {
                                if (polygon[k].id == area[j].id) {
                                    dao.push(polygon[k]);
                                }
                            }
                        }
                    }
                }
            }
            resDao = [];
            for (var i = 0; i < dao.length; i++) {
                for (var j = 0; j < polygon.length; j++) {
                    if (dao[i].id == polygon[j].id)
                        continue;
                    if (PolyInside(dao[i], polygon[j])) {
                        for (var k = 0; k < polygon.length; k++) {
                            if (dao[i].id == polygon[k].id) {
                                resDao.push([k, j]);
                            }
                        }
                    }
                }
            }
        }        

        function CheckIn(array, point) {//检验是否是一个闭合的曲线
            for (var i = 0; i < array.length; i++) {
                if (array[i].point[0] == point[0] && array[i].point[1] == point[1]) {
                    return i;
                }
            }
            return -1;
        }        

        function SortPointArc() {
            for (var k = 0; k < points.length; k++) {
                var arcs = (points[k].arc).slice();
                var p = points[k].point;
                var lines = [];
                for (var i = 0; i < arcs.length; i++) {
                    var now = {};
                    var index = arcs[i];
                    if (p[0] == polylines[index].start[0] && p[1] == polylines[index].start[1]) {
                        now = {
                            id: polylines[index].id, start: p,
                            next: polylines[index].points[1], angle: 0
                        };
                        lines.push(now);
                    }
                    else if (p[0] == polylines[index].end[0] && p[1] == polylines[index].end[1]) {
                        var n = polylines[index].points.length - 2;
                        now = {
                            id: polylines[index].id, start: p,
                            next: polylines[index].points[n], angle: 0
                        };
                        lines.push(now);
                    }
                }
                for (var i = 0; i < lines.length; i++) {
                    var x1 = 1;
                    var y1 = 0;
                    var x2 = lines[i].next[0] - lines[i].start[0];
                    var y2 = lines[i].next[1] - lines[i].start[1];
                    var cos = x2 / Math.sqrt(x2 * x2 + y2 * y2);
                    var theta = Math.acos(cos);
                    var f = x1 * y2 - x2 * y1;
                    if (f < 0) {
                        theta = 2 * Math.PI - theta;
                    }
                    lines[i].angle = theta;
                }
                lines.sort(function (a, b) {
                    return a.angle - b.angle;
                });
                points[k].arc = [];
                for (var i = 0; i < lines.length; i++) {
                    points[k].arc.push(lines[i].id);
                }
            }
        }        

        function mult(a, b, c) {
            return (a[0] - c[0]) * (b[1] - c[1]) - (b[0] - c[0]) * (a[1] - c[1]);
        }       

        function PolyInside(poly1, poly2) {
            var pp = [];
            for (var i = 0; i < poly1.data.length; i++) {
                var index = poly1.data[i].id;
                pp.push(polylines[index].start);
                pp.push(polylines[index].end);
            }
            for (var i = 0; i < pp.length; i++) {
                if (!PointInside(pp[i], poly2))
                    return false;
            }
            return true;
        }

        function Reverse(pline) {
            var result = {
                id: -1,
                start: [],
                end: [],
                points: []
            }
            result.id = pline.id;
            result.start = pline.end.slice();
            result.end = pline.start.slice();
            for (var i = pline.points.length - 1; i >= 0; i--) {
                result.points.push(pline.points[i]);
            }
            return result;
        }

        function PolytoPoint() {
            polypoint = [];
            for (var i = 0; i < polygon.length; i++) {
                var pps = [];
                for (var j = 0; j < polygon[i].length; j++) {
                    var index = polygon[i][j].id;
                    var dir = polygon[i][j].dir;
                    if (dir == "plus") {
                        for (var k = 0; k < polylines[index].points.length - 1; k++) {
                            pps.push(polylines[index].points[k]);
                        }
                    }
                    else {
                        var res = Reverse(polylines[index]);
                        for (var k = 0; k < polylines[index].points.length - 1; k++) {
                            pps.push(res.points[k]);
                        }
                    }
                }
                pps.push(pps[0]);
                polypoint.push(pps);
            }
        }

        function LeftTurn() {
            SortPointArc();
            var ids = [];
            for (var i = 0; i < points.length; i++) {
                ids = [];
                var p = points[i].point; //当前多边形的起点
                var nextpoint = [];
                var k = 0;//取弧段集合中的第k个弧段
                nextpoint = [];
                var index = -1;//取该弧段
                while (k < points[i].arc.length) {
                    index = (points[i].arc)[k];
                    if (p[0] == polylines[index].start[0] && p[1] == polylines[index].start[1] && polylines[index].plus == false) {
                        //如果p为弧段的起点且该弧段的起点-终点方向没有走过
                        polylines[index].plus = true;
                        nextpoint = polylines[index].end;
                        ids.push({ id: polylines[index].id, dir: "plus" });
                        break;
                    }
                    else if (p[0] == polylines[index].end[0] && p[1] == polylines[index].end[1] && polylines[index].minus == false) {
                        //如果p为弧段的终点且该弧段的终点-起点方向没有走过
                        polylines[index].minus = true;
                        nextpoint = polylines[index].start;
                        ids.push({ id: polylines[index].id, dir: "minus" });
                        break;
                    }
                    k++;
                }
                if (k == points[i].arc.length) {
                    continue;
                    //该点的所有相关弧段已经遍历完毕，结束循环并取下一个结点
                }
                //找到next点在结点-弧段表里面对应的index弧段的下一个弧段
                var a = -1;//next点的编号
                while (1) {
                    while (nextpoint[0] != p[0] || nextpoint[1] != p[1]) {
                        for (a = 0; a < points.length; a++) {
                            if (points[a].point[0] == nextpoint[0] && points[a].point[1] == nextpoint[1]) {
                                break;
                            }
                        }
                        var b;
                        var nextindex = -1;//下一个弧段的id
                        for (b = 0; b < points[a].arc.length; b++) {
                            if (points[a].arc[b] == index) {
                                nextindex = (b + 1) % points[a].arc.length;
                                break;
                            }
                        }
                        index = points[a].arc[nextindex];
                        if (nextpoint[0] == polylines[index].start[0] && nextpoint[1] == polylines[index].start[1] && polylines[index].plus == false) {
                            //如果next为弧段的起点且该弧段的起点-终点方向没有走过
                            polylines[index].plus = true;
                            nextpoint = polylines[index].end;
                            ids.push({ id: polylines[index].id, dir: "plus" });
                        }
                        else if (nextpoint[0] == polylines[index].end[0] && nextpoint[1] == polylines[index].end[1] && polylines[index].minus == false) {
                            //如果p为弧段的终点且该弧段的终点-起点方向没有走过
                            polylines[index].minus = true;
                            nextpoint = polylines[index].start;
                            ids.push({ id: polylines[index].id, dir: "minus" });
                        }
                    }
                    polygon.push(ids);
                    var last = ids[ids.length - 1].id;
                    ids = [];
                    if (polylines[last].plus == true && polylines[last].minus == true) {
                        break;
                    }
                    if (p[0] == polylines[last].start[0] && p[1] == polylines[last].start[1] && polylines[last].plus == false) {
                        polylines[last].plus = true;
                        nextpoint = polylines[last].end;
                        ids.push({ id: polylines[last].id, dir: "plus" });
                    }
                    else if (p[0] == polylines[last].end[0] && p[1] == polylines[last].end[1] && polylines[last].minus == false) {
                        polylines[last].minus = true;
                        nextpoint = polylines[last].start;
                        ids.push({ id: polylines[last].id, dir: "minus" });
                    }
                }
            }
        }

        function DrawPolygon(data) {
            ctx.strokeStyle = "red";
            data = data.split('\r\n');
            var count = 0;
            var id = -1;
            for (var i = 0; i < data.length; i++) {
                var line = data[i];
                if (line == "END" && data[i - 1] != "END") {
                    var last = data[i - 1];
                    point = last.split(',');
                    point[0] = parseFloat(point[0]);
                    point[1] = parseFloat(point[1]);
                    ll.end = point;
                    //弧段结点表
                    polylines.push(ll);
                    ctx.stroke();
                    count = 0;
                    var index = CheckIn(points, point);
                    if (index == -1) {
                        //结点弧段表
                        var point = {
                            id: points.length, point: point, arc: [id]
                        }
                        points.push(point);
                    }
                    else {
                        points[index].arc.push(id);
                    }
                    continue;
                }
                var point = line.split(',');
                if (point.length < 2) {
                    count = 1;
                    id = parseInt(point[0]) - 1;
                    var ll = { id: parseInt(point[0]) - 1, start: null, end: null, points: [], plus: false, minus: false };
                    continue;
                }
                else {
                    point[0] = parseFloat(point[0]);
                    point[1] = parseFloat(point[1]);
                }
                if (count == 1) {
                    ctx.beginPath();
                    
                    ctx.moveTo(point[0] * 2 - 20, (canvas.height - point[1]) * 2 - 130);
                    ll.start = point;
                    ll.points.push(point);
                    var index = CheckIn(points, point);
                    if (index == -1) {
                        //结点弧段表
                        var point = {
                            id: points.length, point: point, arc: [id]
                        }
                        points.push(point);
                    }
                    else {
                        points[index].arc.push(id);
                    }
                    count++;
                }
                else {
                    ctx.lineTo(point[0] * 2 - 20, (canvas.height - point[1]) * 2 - 130);
                    ll.points.push(point);
                }ctx.strokeStyle = randomColor();  
            }
        }
        
        function randomColor(){
                    var arrHex=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"];
                    var strHex="#";
                    var index;
                    for(var i=0;i<6;i++){
                        index=Math.round(Math.random()*15);//rounr 四舍五入
                        strHex+=arrHex[index];
                    }
                    return strHex;
                }
    
    </script>
</body>

</html>